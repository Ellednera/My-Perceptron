.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "My::Perceptron 3"
.TH My::Perceptron 3 "2021-08-08" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
My::Perceptron
.SH "VERSION"
.IX Header "VERSION"
Version 0.01
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use AI::Perceptron::Simple;
\&
\&    # the codes are expected to look something like this
\&    $perceptron\->new;
\&
\&    # these three steps could be done in seperated scripts if necessary
\&    # &train and &validate could be put inside a loop or something
\&    $perceptron\->train( $file_train );
\&    $perceptron\->validate( $file_validate );
\&    $perceptron\->test( $file_test );
\&
\&    # show results ie confusion matrix
\&    # (TP\-true positive, TN\-true negative, FP\-false positive, FN\-false negative)
\&    # this should only be done during validation and testing
\&    $perceptron\->generate_confusion_matrix;
\&
\&    # save data of the trained perceptron
\&    $perceptron\->save_data( $data_file );
\&
\&    # load data of percpetron for use in actual program
\&    $perceptron\->load_data( $data_file );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides methods to build, train, validate and test a perceptron. It can also save the data of the 
perceptron for future use of for any actual \s-1AI\s0 programs.
.PP
See wikipedia for more info about perceptron.
.PP
The implementation here is super basic as it only takes in input of the dendrites and calculate the output. If the output is 
higher than the threshold, the final result (category) will be 1 aka perceptron is activated. If not, then the 
result will be 0 (not activated).
.PP
Depending on how you view or categorize the final result, the perceptron will fine tune itself (aka train) based on 
the learning rate until the desired result is met. Everything from here on is all mathematics and numbers. 
The data will only makes sense to the computer and not humans anymore.
.PP
Whenever the perceptron fine tunes itself, it will increase/decrease all the dendrites that is significant (attributes  
labelled 1) for each input. This means that even when the perceptron successfully fine tunes itself to suite all 
the data in your file for the first round, the perceptron might still get some of the things wrong for the next 
round of training. Therefore, the perceptron should be trained for as many rounds as possible. The more \*(L"confusion\*(R" 
the perceptron is able to correctly handle, the more \*(L"mature\*(R" the perceptron is. No one defines how \*(L"mature\*(R" it is 
except the programmer himself/herself :)
.SH "EXPORT"
.IX Header "EXPORT"
None. Almost everything is \s-1OO\s0
.SH "SUBROUTINES/METHODS"
.IX Header "SUBROUTINES/METHODS"
.SS "new ( \e%options )"
.IX Subsection "new ( %options )"
Creates a brand new perceptron and initializes the value of each \s-1ATTRIBUTE\s0 or \*(L"thickness\*(R" of the dendrites :)
.PP
For \f(CW%options\fR, the followings are needed unless mentioned:
.ie n .IP "initial_value => $decimal" 4
.el .IP "initial_value => \f(CW$decimal\fR" 4
.IX Item "initial_value => $decimal"
The value or thickness :) of \s-1ALL\s0 the dendrites when a new perceptron is created.
.Sp
The value should be between 0 and 1.
.ie n .IP "attribs => $array_ref" 4
.el .IP "attribs => \f(CW$array_ref\fR" 4
.IX Item "attribs => $array_ref"
An array reference containing all the attributes the perceptron should have.
.ie n .IP "learning_rate => $decimal" 4
.el .IP "learning_rate => \f(CW$decimal\fR" 4
.IX Item "learning_rate => $decimal"
Optional. The default is \f(CW0.05\fR.
.Sp
The learning rate or the \*(L"rest duration\*(R" of the perceptron for the fine-tuning process (between 0 and 1).
.Sp
Generally speaking, the smaller the value the better.
.ie n .IP "threshold => $decimal" 4
.el .IP "threshold => \f(CW$decimal\fR" 4
.IX Item "threshold => $decimal"
Optional. The default is \f(CW0.5\fR
.Sp
This is the passing rate to determine the neuron output (0 or 1)
.SS "get_attributes"
.IX Subsection "get_attributes"
Obtains a hash of all the attributes of the perceptron
.ie n .SS "learning_rate( $value )"
.el .SS "learning_rate( \f(CW$value\fP )"
.IX Subsection "learning_rate( $value )"
.SS "learning_rate"
.IX Subsection "learning_rate"
If \f(CW$value\fR is given, sets the learning rate to \f(CW$value\fR. If not, then it returns the learning rate.
.PP
The \f(CW$value\fR should be between 0 and 1. Default is \f(CW0.05\fR
.ie n .SS "threshold( $value )"
.el .SS "threshold( \f(CW$value\fP )"
.IX Subsection "threshold( $value )"
.SS "threshold"
.IX Subsection "threshold"
If \f(CW$value\fR is given, sets the threshold/passing rate to \f(CW$value\fR. If not, then it returns the passing rate.
.PP
The \f(CW$value\fR should be between 0 and 1. Default is \f(CW0.5\fR ie 50%
.ie n .SS "train( $stimuli_train_csv, $save_nerve_to_file )"
.el .SS "train( \f(CW$stimuli_train_csv\fP, \f(CW$save_nerve_to_file\fP )"
.IX Subsection "train( $stimuli_train_csv, $save_nerve_to_file )"
Trains the perceptron. \f(CW$stimuli_train\fR is the set of data/input (in \s-1CSV\s0 format) to train the perceptron while \f(CW$save_nerve_to_file\fR is 
the filename that will be generate each time the perceptron finishes the training process. This data file is the data of the \f(CW\*(C`My::Perceptron\*(C'\fR 
object and it is used in the \f(CW\*(C`validate\*(C'\fR method.
.PP
Returns \f(CW$save_nerve_to_file\fR upon completion. This is useful if you are perfrorming the training and validation process in one go. So 
you can write the following if you want to:
.PP
.Vb 3
\&    $perceptron\->validate(  $stimuli_validate, 
\&                            $perceptron\->train( $stimuli_train, $save_nerve_to_file ) 
\&                        );
.Ve
.SS "\fB_process_csv()\fP"
.IX Subsection "_process_csv()"
Returns an array of headers that has the value of 1
.SS "\fB_read_from_csv()\fP"
.IX Subsection "_read_from_csv()"
.SS "\fB_write_to_csv()\fP"
.IX Subsection "_write_to_csv()"
.ie n .SS "&save_perceptron( $nerve_file )"
.el .SS "&save_perceptron( \f(CW$nerve_file\fP )"
.IX Subsection "&save_perceptron( $nerve_file )"
Saves the \f(CW\*(C`My::Perceptron\*(C'\fR object into a \f(CW\*(C`Storable\*(C'\fR file. There shouldn't be a need to call this method manually since after every 
training process this will be called automatically.
.PP
This subroutine is not exported in any way whatsoever.
.PP
This subroutine is to be called in the procedural way. No checking is done currently.
.ie n .SS "&load_perceptron( $nerve_file_to_load )"
.el .SS "&load_perceptron( \f(CW$nerve_file_to_load\fP )"
.IX Subsection "&load_perceptron( $nerve_file_to_load )"
Loads the data and turns it into a \f(CW\*(C`My::Perceptron\*(C'\fR object as the return value.
.PP
This subroutine is not exported in any way whatsoever.
.PP
This subroutine is to be called in the procedural way. No checking is done currently.
.SH "AUTHOR"
.IX Header "AUTHOR"
Raphael Jong Jun Jie, \f(CW\*(C`<ellednera at cpan.org>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-my\-perceptron at rt.cpan.org\*(C'\fR, or through
the web interface at <https://rt.cpan.org/NoAuth/ReportBug.html?Queue=My\-Perceptron>.  I will be notified, and then you'll
automatically be notified of progress on your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc My::Perceptron
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker (report bugs here)
.Sp
<https://rt.cpan.org/NoAuth/Bugs.html?Dist=My\-Perceptron>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<https://cpanratings.perl.org/d/My\-Perceptron>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<https://metacpan.org/release/My\-Perceptron>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Besiyata d'shmaya
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
This software is Copyright (c) 2021 by Raphael Jong Jun Jie.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Artistic License 2.0 (GPL Compatible)
.Ve
